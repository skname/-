### 1. 事件循环
通过事件循环的方式，主线程不停的循环查看消息队列中是否有需要执行的任务，如果有则拿出来执行。通过引入事件循环机制，可以在主线程执行期间，去添加执行新的任务。
### 2. 消息队列
用于存放主线程在执行过程中需要执行的新的任务，IO线程中产生的新任务添加到队列的尾部，IO线程可能产生的任务，资源加载完成，鼠标点击等其他事件。

**注意**：由于是多个线程操作同一个消息队列，所以在添加任务和取出任务时还会加上一个同步锁，这块内容你也要注意下。

### 3. 处理其他进程发送过来的任务
- 通过使用消息队列，我们实现了线程之间的消息通信
- 渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程

### 4. 消息队列中的任务类型
- 输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。
- 除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。

### 5. 页面使用单线程的缺点
1. 如果dom操作同步执行，而操作dom十分频繁，那么这个当前的任务执行时间会被拉长，从而导致执行效率的下降。
2. 如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。
3. 这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的执行效率；如果采用异步方式，又会影响到监控的实时性。

### 6. 微任务的产生
我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

### 宏任务和微任务
- 宏任务：定时器
- 微任务：Promise, MuationObserver,nextTick