### 前置知识
- HTML
- CSS 层叠样式表 stylesheet
- js

### 渲染进程
- 时间线：
  - 构建dom树：HTML解析器将html转化为dom树
  - 样式计算
    - 渲染引擎将 css 文件转换为浏览器可以识别的 styleSheets
    - 转换样式表中的属性值，使其标准化
    - 计算出 DOM 树中每个节点的具体样式
  - 布局阶段：计算出 dom 元素的几何位置
    - 创建布局树：遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中，而不可见的节点会被布局树忽略掉（head标签还有display为none属性的元素）
    - 布局计算：在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来
  - 分层：渲染引擎为特定节点生成专门的图层，形成图层树
    - 并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层
    - 渲染引擎才会为特定的节点创建新的图层的条件：
        1. 拥有层叠上下文属性的元素
        2. 要剪裁（clip）的地方也会被创建为图层
    
  - 绘制
    - 图层绘制：在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表
  - 光栅化
    - 将图块转会为位图，而图块是栅格化执行的最小单位
    - 渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的
    - 栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。
    - 如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作
  - 合成和显示
    - 形成绘制列表后，浏览器进程将该列表提交给结合线程
    - 合成线程将图层划分为图块
    - 然后合成线程会按照视口附近的图块来优先生成位图，生成位图的工作由栅格化来执行
    - 旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。
    - 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到显存中，最后再将内存显示在屏幕上。

### 重排、重绘、合成
- 重排：修改元素的集合属性，渲染进程会重新执行，从样式计算到布局，到生成布局树，生成图层树，绘制，光栅化到合成显示。重排需要更新完整的渲染流水线，所以开销也是最大的。
- 重绘：更改颜色等属性，渲染进程直接从绘制阶段，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。
- 直接合成阶段：更改一个既不要布局也不要绘制的属性，如 `transform` 属性，染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。

### 减少重排重绘的优化方案
减少重排重绘, 方法很多：
1. 使用 class 操作样式，而不是频繁操作 style
2. 避免使用 table 布局
3. 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
4. Debounce window resize 事件
5. 对 dom 属性的读写要分离 
6. will-change: transform 做优化


### 重点摘要
1. 层叠规则
2. css 属性继承
3. 层叠上下文属性
4. 图层表
5. 栅格化